<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<title>Ù…Ø­Ù„Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙˆÙ…Ø­Ø³Ù‘Ù† Ù„Ù„Ø±Ù‚Ù… Ø§Ù„Ù‚ÙˆÙ…ÙŠ (OpenCV + Tesseract)</title>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.8.0/opencv.js" ></script>
<!-- Tesseract.js -->
<script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>

<style>
  body{font-family: Arial, "Segoe UI", Roboto; background:#f4f6f8; padding:18px; color:#222}
  .card{max-width:900px;margin:0 auto;background:#fff;padding:16px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.06)}
  h1{margin:0 0 12px;font-size:20px;color:#084a8a}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  input[type=file]{padding:6px}
  button{padding:10px 12px;border-radius:6px;border:0;background:#0b6bb8;color:#fff;cursor:pointer}
  button.secondary{background:#666}
  canvas{max-width:100%;border:1px solid #ddd;margin-top:8px}
  pre{background:#0f1720;color:#f1f5f9;padding:10px;border-radius:6px;overflow:auto}
  #status{margin-top:8px;color:#0b6bb8}
  .result{margin-top:12px;padding:12px;background:#f7fbff;border-left:4px solid #0b6bb8;border-radius:6px}
</style>
</head>
<body>
<div class="card">
  <h1>Ù…Ø­Ù„Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙˆÙ…Ø­Ø³Ù‘Ù† Ù„Ù„Ø±Ù‚Ù… Ø§Ù„Ù‚ÙˆÙ…ÙŠ Ø§Ù„Ù…ØµØ±ÙŠ</h1>

  <div class="row">
    <label>Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø£Ùˆ Ø§Ù„ØªÙ‚Ø·Ù‡Ø§ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:</label>
    <input id="fileInput" type="file" accept="image/*" />
    <button id="autoBtn">ğŸ” Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠ</button>
    <button id="manualModeBtn" class="secondary">âœ‹ ÙˆØ¶Ø¹ ÙŠØ¯ÙˆÙŠ (ØªØ­Ø¯ÙŠØ¯)</button>
  </div>

  <canvas id="canvas" width=800 height=450></canvas>

  <div class="row" style="margin-top:10px">
    <button id="processCroppedBtn">ğŸ“¤ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹ ÙˆOCR</button>
    <button id="tryEnhanceBtn" class="secondary">âš™ï¸ ØªØ¬Ø±Ø¨Ø© ØªØ­Ø³ÙŠÙ† Ø£Ù‚ÙˆÙ‰</button>
  </div>

  <div id="status">Ø¬Ø§Ù‡Ø².</div>

  <div class="result" id="resultArea" style="display:none">
    <strong>Ø§Ù„Ù†ØªÙŠØ¬Ø©:</strong>
    <div id="ocrText" style="margin-top:8px;white-space:pre-wrap;font-family:monospace"></div>
    <div id="analysis" style="margin-top:10px"></div>
  </div>

  <details style="margin-top:12px">
    <summary>Ù…Ù„Ø§Ø­Ø¸Ø§Øª ØªÙ‚Ù†ÙŠØ© (Ø§Ø¶ØºØ· Ù„Ù„ÙØªØ­)</summary>
    <ul>
      <li>ÙŠØ¹Ù…Ù„ Ù…Ø­Ù„ÙŠÙ‹Ø§ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ Ø¨Ø¯ÙˆÙ† Ø±ÙØ¹ Ù„Ù„Ø³ÙŠØ±ÙØ±.</li>
      <li>Ø¥Ù† Ù„Ù… ØªÙ†Ø¬Ø­ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ Ø¬Ø±Ù‘Ø¨ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ø«Ù… Ø§Ø¶ØºØ· "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹".</li>
      <li>ÙÙŠ Ø­Ø§Ù„Ø§Øª Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³ Ø§Ù„Ù‚ÙˆÙŠ Ø£Ùˆ Ø§Ù„Ø¶Ø¨Ø§Ø¨ÙŠØ© Ø§Ù„Ø´Ø¯ÙŠØ¯Ø© Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ø¹Ø§Ø¯Ø© ØªØµÙˆÙŠØ± Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙƒØ§Ù…ÙŠØ±Ø§ Ø£ÙØ¶Ù„.</li>
    </ul>
  </details>
</div>

<script>
/* ----- Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¹Ø§Ù…Ø© ----- */
const fileInput = document.getElementById('fileInput');
const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
const autoBtn = document.getElementById('autoBtn');
const manualModeBtn = document.getElementById('manualModeBtn');
const processCroppedBtn = document.getElementById('processCroppedBtn');
const tryEnhanceBtn = document.getElementById('tryEnhanceBtn');
const statusDiv = document.getElementById('status');
const resultArea = document.getElementById('resultArea');
const ocrTextDiv = document.getElementById('ocrText');
const analysisDiv = document.getElementById('analysis');

let img = new Image();
let imgDataURL = null;
let selection = null; // {x,y,w,h}
let isManual = false;
let drag = false, sx, sy, ex, ey;

/* ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Canvas */
fileInput.addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = ev=>{
    img.onload = ()=>{
      // Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø© (Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­Ø¬Ù… Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø³Ø±Ø¹Ø©)
      const maxW = 1000;
      const scale = Math.min(1, maxW / img.width);
      canvas.width = Math.round(img.width * scale);
      canvas.height = Math.round(img.height * scale);
      ctx.drawImage(img,0,0,canvas.width,canvas.height);
      imgDataURL = canvas.toDataURL();
      status('ØµÙˆØ±Ø© Ù…Ø­Ù…Ù‘Ù„Ø©. Ø§Ø¶ØºØ· "Ø§Ø³ØªØ®Ø±Ø§Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠ" Ø£Ùˆ ÙØ¹Ù‘Ù„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ù„Ù„ØªØ­Ø¯ÙŠØ¯.');
      selection = null; resultArea.style.display='none';
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(f);
});

/* ÙˆØ¶Ø¹ ÙŠØ¯ÙˆÙŠ Ù„Ù„Ø±Ø³Ù… (Ù…Ø±Ø¨Ø¹ Ø§Ù„ØªØ­Ø¯ÙŠØ¯) */
manualModeBtn.addEventListener('click', ()=> {
  isManual = !isManual;
  manualModeBtn.textContent = isManual ? 'âœ‹ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ: Ù…ÙØ¹Ù„ (Ø§Ø³Ø­Ø¨ Ù„ØªØ­Ø¯ÙŠØ¯)' : 'âœ‹ ÙˆØ¶Ø¹ ÙŠØ¯ÙˆÙŠ (ØªØ­Ø¯ÙŠØ¯)';
  if(isManual) {
    canvas.style.cursor='crosshair';
    status('Ù…Ø±Ø± Ø§Ù„Ù…Ø§ÙˆØ³ ÙˆØ§Ø³Ø­Ø¨ Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø«Ù… Ø§Ø¶ØºØ· "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹ ÙˆOCR".');
  } else {
    canvas.style.cursor='default';
  }
});

canvas.addEventListener('mousedown', e=>{
  if(!isManual) return;
  drag = true;
  const r = canvas.getBoundingClientRect();
  sx = e.clientX - r.left; sy = e.clientY - r.top;
});
canvas.addEventListener('mousemove', e=>{
  if(!drag) return;
  const r = canvas.getBoundingClientRect();
  ex = e.clientX - r.left; ey = e.clientY - r.top;
  redrawImage();
  ctx.strokeStyle='red'; ctx.lineWidth=2; ctx.setLineDash([6,4]);
  ctx.strokeRect(sx, sy, ex-sx, ey-sy);
});
canvas.addEventListener('mouseup', e=>{
  if(!drag) return;
  drag=false;
  selection = normalizeRect(sx,sy,ex,ey);
  redrawImage(); drawSelection();
  status('ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ ÙŠØ¯ÙˆÙŠØ§Ù‹. Ø§Ø¶ØºØ· "Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹ ÙˆOCR".');
});

/* Normalize rectangle coords */
function normalizeRect(x1,y1,x2,y2){
  const x = Math.min(x1,x2), y = Math.min(y1,y2);
  const w = Math.abs(x2-x1), h = Math.abs(y2-y1);
  return {x:Math.round(x), y:Math.round(y), w:Math.round(w), h:Math.round(h)};
}

/* Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© */
function redrawImage(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(img.src) ctx.drawImage(img,0,0,canvas.width,canvas.height);
}

/* Ø±Ø³Ù… Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ù…Ø­Ø¯Ø¯ */
function drawSelection(){
  if(!selection) return;
  ctx.strokeStyle='lime'; ctx.lineWidth=2; ctx.setLineDash([]);
  ctx.strokeRect(selection.x, selection.y, selection.w, selection.h);
}

/* ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ */
function status(t){ statusDiv.innerText = t; }

/* ----- Ø§ÙƒØªØ´Ø§Ù ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø­ØªÙ…Ù„ Ø£Ù† ØªØ­ØªÙˆÙŠ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù‚ÙˆÙ…ÙŠ ----- */
autoBtn.addEventListener('click', async ()=>{
  if(!img.src) return alert('Ø­Ù…Ù‘Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹.');
  status('ğŸ” Ø¬Ø§Ø±Ù Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ù…Ù†Ø·Ù‚Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹...');
  await waitForOpencv();
  try {
    const mat = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(mat, gray, cv.COLOR_RGBA2GRAY, 0);

    // ØªØµØºÙŠØ± Ù„Ù„ØµÙˆØ±Ø© Ù„Ù„ØªØ³Ø±ÙŠØ¹ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ÙƒØ¨ÙŠØ±Ø©
    const MAX_DIM = 1000;
    let scale = 1;
    if (gray.cols > MAX_DIM) scale = MAX_DIM / gray.cols;
    if (scale !== 1) {
      let tmp = new cv.Mat();
      cv.resize(gray, tmp, new cv.Size(0,0), scale, scale, cv.INTER_AREA);
      gray.delete();
      gray = tmp;
    }

    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø±Ø´Ø­ Ø³ÙˆØ¨Ù„ Ù„Ø¥Ø¨Ø±Ø§Ø² Ø§Ù„Ø­ÙˆØ§Ù Ø§Ù„Ø£ÙÙ‚ÙŠØ© (Ø§Ù„Ø´Ø±Ø§Ø¦Ø· / Ø³Ø·ÙˆØ± Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ØºØ§Ù„Ø¨Ø§Ù‹ ØªÙƒÙˆÙ† Ø£ÙÙ‚ÙŠØ©)
    let gradX = new cv.Mat();
    cv.Sobel(gray, gradX, cv.CV_32F, 1, 0, 3, 1, 0, cv.BORDER_DEFAULT);
    cv.convertScaleAbs(gradX, gradX);
    
    // ØªØ¹Ø²ÙŠØ² Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø£ÙÙ‚ÙŠØ©: Ø¹Ù…Ù„ Morphological close Ø«Ù… open
    let thresh = new cv.Mat();
    cv.threshold(gradX, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
    let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(30,3));
    let closed = new cv.Mat();
    cv.morphologyEx(thresh, closed, cv.MORPH_CLOSE, kernel);
    let opened = new cv.Mat();
    let kernel2 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
    cv.morphologyEx(closed, opened, cv.MORPH_OPEN, kernel2);

    // Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø­ØªÙˆÙŠØ§Øª (contours)
    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(opened, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    // Ø§Ø®ØªÙŠØ§Ø± Ø£ÙØ¶Ù„ contour Ø§Ø¹ØªÙ…Ø§Ø¯Ù‹Ø§ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø­Ø© ÙˆØ§Ù„Ù†Ø³Ø¨Ø© (Ù…Ø³ØªØ·ÙŠÙ„ Ø£ÙÙ‚ÙŠ Ø·ÙˆÙŠÙ„)
    let best = null;
    for(let i=0;i<contours.size();i++){
      const cnt = contours.get(i);
      const rect = cv.boundingRect(cnt);
      const area = rect.width * rect.height;
      const aspect = rect.width / (rect.height + 1);
      // Ù…Ø¹Ø§ÙŠÙŠØ± Ù…Ø¨Ø¯Ø¦ÙŠØ©: Ù…Ø³Ø§Ø­Ø© Ù„Ø§ ØªÙ‚Ù„ Ø¹Ù† Ù†Ø³Ø¨Ø© Ù…Ù† Ø§Ù„ØµÙˆØ±Ø©ØŒ ÙˆÙ†Ø³Ø¨Ø© Ø·ÙˆÙ„/Ø§Ø±ØªÙØ§Ø¹ Ù…Ù†Ø§Ø³Ø¨Ø©
      if(area < (gray.cols*gray.rows)*0.005) { cnt.delete(); continue; }
      if(aspect < 3) { cnt.delete(); continue; } // Ù†Ø­ØªØ§Ø¬ Ù…Ø³ØªØ·ÙŠÙ„ Ø£ÙÙ‚ÙŠ Ø¹Ø±ÙŠØ¶
      if(!best || area > best.area) best = {rect, area};
      cnt.delete();
    }

    // ØªØ­ÙˆÙŠÙ„ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ·ÙŠÙ„ Ø¥Ù„Ù‰ Ù…Ù‚Ø§Ø³ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ø§Ù„Ø£ØµÙ„ÙŠ (Ø¥Ø°Ø§ ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ù…Ù‚ÙŠØ§Ø³)
    if(best){
      const r = best.rect;
      const invScale = 1/scale;
      selection = {
        x: Math.max(0, Math.round(r.x * invScale)),
        y: Math.max(0, Math.round(r.y * invScale)),
        w: Math.round(r.width * invScale),
        h: Math.round(r.height * invScale)
      };
      redrawImage(); drawSelection();
      status('âœ… ØªÙ… Ø§ÙƒØªØ´Ø§Ù Ù…Ù†Ø·Ù‚Ø© Ù…Ø±Ø´Ù‘Ø­Ø©. Ø§Ø¶ØºØ· Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹ ÙˆOCR.');
    } else {
      status('âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¹Ù„Ù‰ Ù…Ù†Ø·Ù‚Ø© Ù…Ù†Ø§Ø³Ø¨Ø©. Ø¬Ø±Ù‘Ø¨ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ.');
    }

    // ØªÙ†Ø¸ÙŠÙ
    mat.delete(); gray.delete(); gradX.delete(); thresh.delete();
    kernel.delete(); closed.delete(); opened.delete(); kernel2.delete();
    contours.delete(); hierarchy.delete();
  } catch(err){
    console.error(err); status('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: '+err.message);
  }
});

/* ----- Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹ + ØªØ­Ø³ÙŠÙ† + OCR ----- */
processCroppedBtn.addEventListener('click', async ()=>{
  if(!img.src) return alert('Ø­Ù…Ù‘Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹.');
  if(!selection) return alert('Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ù†Ø·Ù‚Ø©. Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø£Ùˆ Ø­Ø¯Ø¯ ÙŠØ¯ÙˆÙŠØ§Ù‹.');
  await performCropEnhanceAndOCR(selection);
});

/* Ø²Ø± ØªØ¬Ø±Ø¨Ø© ØªØ­Ø³ÙŠÙ† Ø£Ù‚ÙˆÙ‰ */
tryEnhanceBtn.addEventListener('click', async ()=>{
  if(!selection) return alert('Ø­Ø¯Ø¯ Ù…Ù†Ø·Ù‚Ø© Ø£ÙˆÙ„Ø§Ù‹');
  status('âš™ï¸ ØªØ¬Ø±Ø¨Ø© Ø³Ù„Ø³Ù„Ø© ØªØ­Ø³ÙŠÙ† Ø£Ù‚ÙˆÙ‰...');
  await performCropEnhanceAndOCR(selection, {strongEnhance:true});
});

/* Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©: ØªÙ‚Ø·ÙŠØ¹ â†’ ØªØ­Ø³ÙŠÙ† â†’ OCR */
async function performCropEnhanceAndOCR(sel, opts={strongEnhance:false}){
  status('â¬‡ï¸ ØªÙ‚Ø·ÙŠØ¹ Ø§Ù„Ù…Ù†Ø·Ù‚Ø©...');
  // Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹Ø© Ø¹Ù„Ù‰ ÙƒØ§Ù†ÙØ§Ø³ Ù…Ø¤Ù‚Øª
  const tmpC = document.createElement('canvas');
  tmpC.width = sel.w; tmpC.height = sel.h;
  const tctx = tmpC.getContext('2d');
  tctx.drawImage(img, 0, 0, canvas.width, canvas.height); 
  // Ù…Ù„Ø§Ø­Ø¸Ø©: Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ù€canvas Ù‚Ø¯ ØªÙƒÙˆÙ† Ù…Ù‚ÛŒÙ‘Ø³Ø©. Ù„Ø°Ù„Ùƒ Ù†Ø¹ÙŠØ¯ Ø§Ù„Ø±Ø³Ù… Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù†Ø³Ø¨Ø© ÙØ¹Ù„ÙŠÙ‘Ø©:
  // Ø§Ø³ØªØ®Ø¯Ù… ØµÙˆØ±Ø© Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø£Ø¨Ø¹ÙØ¯ Ø§Ù„ØªÙØµÙŠÙ„: Ø³Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø© ÙƒÙ…Ø§ Ù‡ÙŠ.
  tctx.drawImage(img, (sel.x/canvas.width)*img.width, (sel.y/canvas.height)*img.height, (sel.w/canvas.width)*img.width, (sel.h/canvas.height)*img.height, 0,0, tmpC.width, tmpC.height);

  // Ø§Ù„Ø¢Ù† Ù†Ù‚ÙˆÙ… Ø¨Ù…Ø±Ø­Ù„Ø© ØªØ­Ø³ÙŠÙ† Ù…ØªÙ‚Ø¯Ù…Ø© Ø¹Ø¨Ø± OpenCV
  await waitForOpencv();
  let src = cv.imread(tmpC);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

  // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡
  if(opts.strongEnhance) cv.bilateralFilter(gray, gray, 9, 75, 75);
  else cv.GaussianBlur(gray, gray, new cv.Size(3,3), 0);

  // CLAHE Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ¨Ø§ÙŠÙ† (Ù…ÙÙŠØ¯ Ù„ØµÙˆØ± Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª)
  try{
    let clahe = new cv.CLAHE(2.0, new cv.Size(8,8));
    let cl = new cv.Mat();
    clahe.apply(gray, cl);
    gray.delete(); gray = cl; clahe.delete();
  } catch(e){
    // Ø¨Ø¹Ø¶ Ù†Ø³Ø® OpenCV.js Ù‚Ø¯ Ù„Ø§ ØªØ¯Ø¹Ù… CLAHE â€” Ø­ÙŠÙ†Ù‡Ø§ Ù†ØªØ¬Ø§Ù‡Ù„
  }

  // Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙˆØ­ÙŠØ¯ Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©: adaptiveThreshold
  let bin = new cv.Mat();
  cv.adaptiveThreshold(gray, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 21, 10);

  // Ø¥Ø¬Ø±Ø§Ø¡ Ø¥ØºÙ„Ø§Ù‚ ØµØºÙŠØ± Ù„Ø¥ÙƒÙ…Ø§Ù„ Ø­Ø±ÙˆÙ Ø±Ù‚Ù…ÙŠØ© Ù…ÙØµÙˆÙ„Ø©
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);

  // Ø¹ÙƒØ³ Ø§Ù„Ù„ÙˆÙ† Ø¥Ø°Ø§ Ù„Ø²Ù… (Ù†Ø³ØªØ®Ø¯Ù… THRESH_BINARY_INV ÙÙˆÙ‚ØŒ Ù„Ø°Ø§ Ù†Øµ Ø£Ø¨ÙŠØ¶ Ø¹Ù„Ù‰ Ø®Ù„ÙÙŠØ© Ø³ÙˆØ¯Ø§Ø¡)
  // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ imageData Ù„Ù„Ù€ Tesseract (Ù†Ø­ØªØ§Ø¬ Ø±Ø³Ù… ØµÙˆØ±Ø© Ø¨Ù†Ù…Ø· Ø¹Ø§Ø¯ÙŠ: Ø£Ø³ÙˆØ¯/Ø£Ø¨ÙŠØ¶)
  // Ø³Ù†Ø­ÙˆÙ‘Ù„ Ø§Ù„Ù„ÙˆÙ† Ù„Ù„Ø£Ø¨ÙŠØ¶ Ø¹Ù„Ù‰ Ø®Ù„ÙÙŠØ© Ø¨ÙŠØ¶Ø§Ø¡ Ø¨Ø­ÙŠØ« Tesseract ÙŠÙ‚Ø±Ø£Ù‡Ø§ Ø£ÙØ¶Ù„
  let out = new cv.Mat();
  cv.bitwise_not(bin, out);
  // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø­Ø¬Ù… Ù„Ù„Ù€ OCR (ØªÙƒØ¨ÙŠØ± Ø¨Ø³ÙŠØ·)
  const SCALE_UP = 2;
  let up = new cv.Mat();
  cv.resize(out, up, new cv.Size(out.cols * SCALE_UP, out.rows * SCALE_UP), 0, 0, cv.INTER_CUBIC);

  // Ø·Ø¨Ø§Ø¹Ø© ØµÙˆØ±Ø© Ù„Ù„ØªØµÙˆÙ‘Ø± (Ø§Ø®ØªÙŠØ§Ø±ÙŠØŒ ÙŠØ¹Ø±Ø¶ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³)
  cv.imshow(tmpC, up);

  // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù†Ù‚Ù„ Ø¥Ù„Ù‰ Tesseract
  const dataURL = tmpC.toDataURL('image/png');

  // ØªÙ†Ø¸ÙŠÙ Ù…Ø¤Ù‚Øª
  src.delete(); gray.delete(); bin.delete(); out.delete(); up.delete(); kernel.delete();

  status('â³ Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ OCR (Tesseract)...');
  // Ù…Ø­Ø§ÙˆÙ„Ø© Ù‚Ø±Ø§Ø¡Ø© Ø¨Ø§Ù„Ù„ØºØªÙŠÙ†Ø› Ø³Ù†Ø­Ø§ÙˆÙ„ Ø§Ø³ØªÙ‡Ø¯Ø§Ù Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¹Ø¨Ø± "eng" Ø£ÙŠØ¶Ø§Ù‹ Ù„Ø²ÙŠØ§Ø¯Ø© ÙØ±Øµ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„Ù„Ø§ØªÙŠÙ†ÙŠØ©
  try {
    const worker = Tesseract.createWorker({
      logger: m => {
        if(m.status === 'recognizing text') status('â³ OCR: ' + Math.round(m.progress*100) + '%');
      }
    });
    await worker.load();
    await worker.loadLanguage('eng+ara');
    await worker.initialize('eng+ara');
    // Force OEM/LSTM not available control isn't exposed in tesseract.js easily, so just run
    const { data: { text } } = await worker.recognize(dataURL);
    await worker.terminate();

    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù†Øµ: ØªØ­ÙˆÙŠÙ„ Ø£Ø±Ù‚Ø§Ù… Ø¹Ø±Ø¨ÙŠØ© Ø´Ø±Ù‚ÙŠØ© Ø¥Ù„Ù‰ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©ØŒ ÙˆØ¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… ÙÙ‚Ø·
    const converted = convertArabicNums(text || '');
    const digitsOnly = converted.replace(/\D/g,'');
    // 14-digit match
    let match = digitsOnly.match(/[23]\d{13}/);
    // Ø¥Ø°Ø§ Ù„Ù… ÙŠØ¬Ø¯ØŒ Ù†Ø¬Ø±Ø¨ Ù…Ø­Ø§ÙˆÙ„Ø© Ø£Ø®Ø° Ø¢Ø®Ø± 14 Ø±Ù‚Ù… (Ø£Ø­ÙŠØ§Ù†Ù‹Ø§ ÙŠØ¸Ù‡Ø± Ø¨Ù‚ÙŠØ© Ø§Ù„Ù†Øµ Ø£ÙˆÙ„Ù‹Ø§)
    if(!match && digitsOnly.length >= 14){
      match = [digitsOnly.slice(-14)];
    }

    if(match){
      const nid = match[0];
      status('âœ… ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ù‚Ù… Ù‚ÙˆÙ…ÙŠ Ù…Ø±Ø¬Ù‘Ø­: ' + nid);
      resultArea.style.display = 'block';
      ocrTextDiv.textContent = text.trim();
      analyzeID(nid);
    } else {
      status('âŒ Ù„Ù… ÙŠØ¹Ø«Ø± OCR Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ù…ÙƒÙˆÙ‘Ù† Ù…Ù† 14 Ø±Ù‚Ù…. Ø¬Ø±Ø¨ "ØªØ¬Ø±Ø¨Ø© ØªØ­Ø³ÙŠÙ† Ø£Ù‚ÙˆÙ‰" Ø£Ùˆ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„ÙŠØ¯ÙˆÙŠ.');
      resultArea.style.display = 'block';
      ocrTextDiv.textContent = text.trim() || '[Ù„Ù… ØªÙØ³ØªØ®Ø±Ø¬ Ù†ØµÙˆØµ]';
      analysisDiv.innerHTML = '<i>Ù„Ù… ÙŠØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø±Ù‚Ù… Ù‚ÙˆÙ…ÙŠ ØµØ§Ù„Ø­.</i>';
    }
  } catch(err){
    console.error(err);
    status('Ø®Ø·Ø£ ÙÙŠ OCR: ' + err.message);
  }
}

/* ----- ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù‚ÙˆÙ…ÙŠ ÙˆØ¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ----- */
function analyzeID(id){
  const nid = id.toString();
  const century = nid[0] === '2' ? '19' : '20';
  const year = parseInt(nid.substr(1,2),10);
  const month = parseInt(nid.substr(3,2),10);
  const day = parseInt(nid.substr(5,2),10);
  const birthY = parseInt(century + (year<10 ? '0'+year : ''+year),10);
  const birthDate = new Date(birthY, month-1, day);
  const today = new Date();
  let ageY = today.getFullYear() - birthDate.getFullYear();
  let ageM = today.getMonth() - birthDate.getMonth();
  let ageD = today.getDate() - birthDate.getDate();
  if(ageD < 0){ ageM--; ageD += new Date(today.getFullYear(), today.getMonth(), 0).getDate(); }
  if(ageM < 0){ ageY--; ageM += 12; }

  const gender = (parseInt(nid.charAt(12),10) % 2) === 0 ? 'Ø£Ù†Ø«Ù‰' : 'Ø°ÙƒØ±';
  const govs = {"01":"Ø§Ù„Ù‚Ø§Ù‡Ø±Ø©","02":"Ø§Ù„Ø¥Ø³ÙƒÙ†Ø¯Ø±ÙŠØ©","03":"Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯","04":"Ø§Ù„Ø³ÙˆÙŠØ³","11":"Ø¯Ù…ÙŠØ§Ø·","12":"Ø§Ù„Ø¯Ù‚Ù‡Ù„ÙŠØ©","13":"Ø§Ù„Ø´Ø±Ù‚ÙŠØ©","14":"Ø§Ù„Ù‚Ù„ÙŠÙˆØ¨ÙŠØ©","15":"ÙƒÙØ± Ø§Ù„Ø´ÙŠØ®","16":"Ø§Ù„ØºØ±Ø¨ÙŠØ©","17":"Ø§Ù„Ù…Ù†ÙˆÙÙŠØ©","18":"Ø§Ù„Ø¨Ø­ÙŠØ±Ø©","19":"Ø§Ù„Ø¥Ø³Ù…Ø§Ø¹ÙŠÙ„ÙŠØ©","21":"Ø§Ù„Ø§Ù„Ø¬ÙŠØ²Ø©","21":"Ø§Ù„Ø¬ÙŠØ²Ø©","22":"Ø¨Ù†ÙŠ Ø³ÙˆÙŠÙ","23":"Ø§Ù„ÙÙŠÙˆÙ…","24":"Ø§Ù„Ø£Ù‚ØµØ±","25":"Ø³ÙˆÙ‡Ø§Ø¬","26":"Ù‚Ù†Ø§","27":"Ø£Ø³ÙˆØ§Ù†","28":"Ø£Ø³ÙŠÙˆØ·","29":"Ù…Ø·Ø±ÙˆØ­","31":"Ø´Ù…Ø§Ù„ Ø³ÙŠÙ†Ø§Ø¡","32":"Ø¬Ù†ÙˆØ¨ Ø³ÙŠÙ†Ø§Ø¡","33":"Ø§Ù„Ø¨Ø­Ø± Ø§Ù„Ø£Ø­Ù…Ø±","88":"Ø®Ø§Ø±Ø¬ Ø§Ù„Ø¬Ù…Ù‡ÙˆØ±ÙŠØ©"};
  const gov = govs[nid.substr(7,2)] || 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';

  analysisDiv.innerHTML = `
    <div><b>Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù‚ÙˆÙ…ÙŠ:</b> ${nid}</div>
    <div><b>ØªØ§Ø±ÙŠØ® Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯:</b> ${birthDate.toLocaleDateString('ar-EG')}</div>
    <div><b>Ø§Ù„Ø¹Ù…Ø±:</b> ${ageY} Ø³Ù†Ø©ØŒ ${ageM} Ø´Ù‡Ø±ØŒ ${ageD} ÙŠÙˆÙ…</div>
    <div><b>Ø§Ù„Ø¬Ù†Ø³:</b> ${gender}</div>
    <div><b>Ø§Ù„Ù…Ø­Ø§ÙØ¸Ø© (Ø±Ù…Ø²):</b> ${nid.substr(7,2)} â†’ ${gov}</div>
  `;
}

/* ----- Ù…Ø³Ø§Ø¹Ø¯Ø©: Ø§Ù†ØªØ¸Ø§Ø± ØªØ­Ù…ÙŠÙ„ OpenCV ----- */
function waitForOpencv(){
  return new Promise((resolve,reject)=>{
    if(typeof cv !== 'undefined' && cv && cv.Mat) return resolve();
    let t=0;
    const iv = setInterval(()=>{
      if(typeof cv !== 'undefined' && cv && cv.Mat){ clearInterval(iv); resolve(); }
      t+=100;
      if(t>15000){ clearInterval(iv); reject(new Error('OpenCV.js failed to load')); }
    },100);
  });
}

/* ØªØ­ÙˆÙŠÙ„ Ø£Ø±Ù‚Ø§Ù… Ø¹Ø±Ø¨ÙŠØ© Ø´Ø±Ù‚ÙŠØ© Ø¥Ù„Ù‰ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© */
function convertArabicNums(str){
  if(!str) return '';
  const map = {'Ù ':'0','Ù¡':'1','Ù¢':'2','Ù£':'3','Ù¤':'4','Ù¥':'5','Ù¦':'6','Ù§':'7','Ù¨':'8','Ù©':'9'};
  return str.replace(/[Ù -Ù©]/g, d => map[d]);
}
</script>
</body>
</html>
